@codable()
@tokenize()
enum Token {

  @token(pattern: "<!--(.*?)-->")
  case comment(value: String)

  @token(pattern: "<([a-zA-Z]+)", action: push("inside"))
  case open(value: String)

  @token(pattern: "</", action: push("inside"))
  case slashOpen()

  @token(pattern: "([^<&]+)")
  case text(value: String)
  
  /**
   * The "inside" state parses the inside of XML tags
   */
  @token(state: "inside", pattern: "[ \t\r\n]", discard: true)
  case whitespace()

  @token(state: "inside", pattern: "\"([^<\"]*)\"")
  @token(state: "inside", pattern: "'([^<']*)'")
  case string(value: String)

  @token(state: "inside", pattern: "([a-zA-Z]+)")
  case name(value: String)

  @token(state: "inside", pattern: "=")
  case equals()

  @token(state: "inside", pattern: ">", action: pop())
  case close()

  @token(state: "inside", pattern: "/>", action: pop())
  case slashClose()
}

@parse(pattern: [self.name, Token.equals, self.value])
struct XMLAttribute {

  @parse(pattern: Token.name)
  let name: String = ""
  
  @parse(pattern: Token.string)
  let value: String = ""
}

@parse()
enum XMLElementContent {

  @parse(pattern: Token.text)
  case charData(value: String)

  @parse(pattern: Token.comment)
  case comment(value: String)

  @parse(pattern: XMLElement)
  case element(value: XMLElement)
}

@parse(pattern: [
  self.name, 
  self.attributes,
  or([
      Token.close, 
      self.content, 
      Token.slashOpen, 
      Token.name,
      Token.close
    ],
    Token.slashClose)
])
struct XMLElement {

  @parse(pattern: Token.open)
  let name: String = ""

  @parse(pattern: many(XMLAttribute))
  let attributes: Array<XMLAttribute> = []

  @parse(pattern: many(XMLElementContent))
  let content: Array<XMLElementContent> = []
}