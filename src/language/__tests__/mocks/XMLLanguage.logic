@codable()
@tokenize()
enum Token {

  @token(pattern: "<!--(.*?)-->")
  @print(pattern: ["<!--", 0, "-->"])
  case comment(value: String)

  @token(pattern: "</", action: push("inside"))
  case slashOpen()

  @token(pattern: "<", action: push("inside"))
  case open()

  @token(pattern: "([^<&]+)")
  @print(pattern: 0)
  case text(value: String)
  
  /**
   * The "inside" state parses the inside of XML tags
   */
  @token(state: "inside", pattern: "[ \t\r\n]", discard: true)
  case whitespace()

  @token(state: "inside", pattern: "\"([^<\"]*)\"")
  @token(state: "inside", pattern: "'([^<']*)'")
  @print(pattern: ["\"", 0, "\""])
  case string(value: String)

  @token(state: "inside", pattern: "([a-zA-Z]+)")
  @print(pattern: 0)
  case name(value: String)

  @token(state: "inside", pattern: "=")
  case equals()

  @token(state: "inside", pattern: ">", action: pop())
  case close()

  @token(state: "inside", pattern: "/>", action: pop())
  case slashClose()
}

@parse(pattern: [self.name, Token.equals, self.value])
struct XMLAttribute {

  let name: String = ""
  
  @parse(pattern: Token.string)
  let value: String = ""
}

@parse()
enum XMLElementContent {

  @parse(pattern: Token.text)
  case charData(value: String)

  case comment(value: String)

  case element(value: XMLElement)
}

@parse(pattern: [
  Token.open,
  self.name, 
  self.attributes,
  or(
    Token.slashClose, 
    [
      Token.close, 
      self.content, 
      Token.slashOpen, 
      Token.name,
      Token.close
    ])
])
@print(pattern: [
  Token.open,
  self.name, 
  indent(join(self.attributes, line(), leading: line())),
  Token.close,
  self.content,
  Token.slashOpen, 
  self.name,
  Token.close
])
struct XMLElement {

  @parse(pattern: Token.name)
  let name: String = ""

  let attributes: Array<XMLAttribute> = []

  let content: Array<XMLElementContent> = []
}